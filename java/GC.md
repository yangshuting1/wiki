## GC

### 干货

#### 1. 如何确定某个对象是回收对象?
     
java ：可达性分析法

python：引用计数法

可达性分析：创建一系列的‘GC roots’对象作为起点进行搜索，如果一系列的“GC roots" 与一个对象没有任何路径，则被称为不可达对象。不可达对象会再经历两次标记，如果仍没有任何路径，就会被认定为垃圾回收对象

#### 2.常见的将对象判定为可回收对象的情况：

1. 引用赋值为null 

```java

object obj = new object();
ob = null;

```
2.已经指向某个对象的引用又指向新的对象
 
```java

object obj1=new object();
object obj2=new object();

obj1= obj2;

```
3.局部引用所指向的对象

```java
void method(){
   for(int i =0;i<=10;i++){
        object obj3 = new object();
        System.out.println(obj3.getClass());
   }
}

```
4. 弱引用关联的对象
 
```java
WeakReference<String> wr = new WeakReference<String>(new String("world"));

```

#### 3.典型的垃圾收集算法

##### Mark-Sweep（标记-清除）算法

思路：两个阶段：标记阶段和清除阶段；标记出所有需要被回收的对象，回收被标记的对象所占用的空间

缺点：容易产生内存碎片，导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

##### Copying（复制）算法

思路：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。

缺点：如果存活对象很多，那么Copying算法的效率将会大大降低。

##### Mark-Compact（标记-整理）算法

思路：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存

##### Generational Collection（分代收集）算法

思路：据对象存活的生命周期将内存划分为若干个不同的区域.
     
     老年代的特点是每次垃圾收集时只有少量对象需要被回收(Mark-Compact)
     
     新生代的特点是每次垃圾回收时都有大量的对象需要被回收(copying)
     
**新年代：** 新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说发生了一次“minor GC”。

**老年代：** 没有变得不可达，存活下来的年轻代对象被复制到这里。这块内存区域一般大于年轻代。因为它更大的规模，GC发生的次数比在年轻代的少。对象从老年代消失时，我们说“major GC”（或“full GC”）发生了。


#### 基础
##### 1. 触发GC（Garbage Collector）的条件

1. 系统空闲时执行，GC在优先级最低的线程中运行，但下面的条件例外。
2. Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制调用GC线程。若GC一次之后仍不能满足内存分配，JVM会再进行两次GC，若仍无法满足要求，则JVM将报“out of memory”的错误，Java应用将停止。

##### 2. 两个重要方法
1. System.gc()方法

使用System.gc()可以请求Java的垃圾回收。不确定会立即执行
查看Java使用的堆内存的情况:  **java -verbosegc classfile **
影响系统性能，不推荐使用

2. finalize()方法

Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。

##### 3. 如何减少GC开销的措施

1. 不要显式调用System.gc()。
2. 尽量减少临时对象的使用
3. 对象不用时最好显式置为Null
4. 尽量使用StringBuffer,而不用String来累加字符串
5. 能用基本类型如Int,Long,就不用Integer,Long对象。
6. 尽量少用静态对象变量

##### 4. minor GC/Major GC/full GC

minor GC: 清理年轻代    
Major GC: 清理老年代
full GC:  清理整个堆空间—包括年轻代和老年代

##### 5. 触发Minor GC。
Eden区满时，触发Minor GC。

##### 6. Full GC触发条件：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法去空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小




### QS：GC是在什么时候，对什么东西，做了什么事情？

#### 什么时候？ 
系统空闲时执行或Java堆内存不足时，GC会被调用。而触发的依据是根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。

   better:能说出新生代、老年代结构，能提出minor gc/full gc 

#### 对什么东西？
从root搜索，通过可达性分析法得到**搜索到的对象**和**无法搜索到的对象**。对于没有搜索到的对象做第一次标记。

#### 做什么事情？
搜索到的对象做**复制**操作
无法搜索到的对象进行**删除**，腾出内存空间。

具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。

第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。

第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。

GC过程中用到的回收算法：
Java堆中的年轻代和老年代采用了不同的回收算法。年轻代采用了复制法；而老年代采用了标记-整理法


